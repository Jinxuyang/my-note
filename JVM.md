[TOC]



##  什么是JVM

JVM(Java Virtual Machine) 用于运行Java字节码，负责装载字节码到其内部，解释\编译为对应平台的机器指令执行；JVM直接运行在操作系统之上，与硬件没有直接交互

![image-20210604212423625](https://gitee.com/vergeee/static-repo/raw/master//img/20210604212430.png)

特点：

1. 一次编译到处运行

![image-20210604213521386](https://gitee.com/vergeee/static-repo/raw/master//img/20210604213521.png)

1. 自动内存管理
2. 自动垃圾回收

## 一些JVM

- SUN Classic

- Exact VM

- HotSpot VM ：HotSpot指热点代码探测技术**目前还在Oracle JDK 和Open JDK仍在使用**

- BEA JRockit：(BEA 已被Oracle收购) 专注于服务端应用，世界最快的jvm之一

- IBM J9

- Taobao JVM: 目前已经在淘宝、天猫上线，替换了Oracle官方JVM；

- Graal VM: Oracle 2018年4月公开，口号 Run Programs Faster Anywhere.最可能替代HotSpot的产品



- Dalvik VM
  - Google开发，基于Android，在Android 2.2 提供JIT
  - 不能成为Java虚拟机，没有遵循JVM的规范
  - 基于寄存器架构，系统耦合度高，效率高
  - 不能执行class文件，执行dex文件
  - Android 5.0使用支持提前编译的ART VM替换Dalvik VM



## Java 代码执行流程

![image-20210604215248082](https://gitee.com/vergeee/static-repo/raw/master//img/20210604215248.png)

Java 代码通过Java编译器生成字节码文件后交给JVM进行执行







## JVM的整体结构（HotSpot VM）

HotSpot VM采用解释器与即时编译器并存的架构

![第02章_JVM架构-英](https://gitee.com/vergeee/static-repo/raw/master//img/20210615131534.jpg)

## 类加载器子系统

- 负责从文件系统或网络中加载class文件，class文件在文件开头有特殊标识（CAFEBABE）
- 类加载器子系统只负责class文件的加载、至于是否可以运行取决于Execution Engine（执行引擎）
- 加载的类的信息存放于一块称为方法区的内存空间。除类信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

### 类的加载过程

![image-20210615134037433](https://gitee.com/vergeee/static-repo/raw/master//img/20210615134037.png)

#### 加载

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java. lang.Class对象，作为方法区这个类的各种数据的访问入口



补充:加载. class文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景: Web Applet
- 从zip压缩包中读取，成为日后jar、war格式的基础
- 运行时计算生成，使用最多的是:动态代理技术.
- 由其他文件生成，典型场景: JSP应用
- 从专有数据库中提取.class文件,比较少见
- 从加密文件中获取，典型的防Class文件被反编译的保护措施

#### 链接

##### 验证

- 确保Class文件字节流中包含的信息符合当前虚拟机的需要，保证被加载类的正确性，不会危害计算机
- 主要包括文件格式验证，元数据验证，字节码验证，符号引用验证

##### 准备  

- 为类变量(静态变量)分配内存并设置该类变量的默认值
- 这里不包含final修饰的static，final在编译时就分配了，准备阶段中只会显示的初始化
- 不会为实例变量(成员变量)分配初始化，类变量会分配在方法区中，实例变量是会随着对象一起分配的Java堆中
- ![img](https://gitee.com/vergeee/static-repo/raw/master//img/20210706192442.png)

##### 解析

- **将常量池内的符号引用转换为直接引用的过程。**
- 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
- 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型**等。对应常量池中的CONSTANT Class_ info、 CONSTANT Fieldref info、 CONSTANT Methodref_ info等。

#### 初始化

- 初始化阶段就是执行类构造方法`<clinit>()`的过程
- 此方法不需要定义，是javac编译器自动收集类中所有**类变量的赋值动作**和**静态代码块中的语句**合并而来
- `<clinit>()`不同于类的构造（构造器是虚拟机视角下的`<init>()`）
- 若该类具有父类，JVM会保证子类`<clinit>()`执行前父类`<clinit>()`执行完毕
- 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁

### 类加载器的分类

分为两种类型

- 引导类加载器（Bootstrap ClassLoader）
- 自定义类加载器（User-Defined ClassLoader）（所有派生于抽象类ClassLoader的类加载器）

![image-20210615154532692](https://gitee.com/vergeee/static-repo/raw/master//img/20210615154532.png)

这四者是包含关系，不是上层下层，也不是父子类继承关系

#### 启动（引导）类加载器（Bootstrap ClassLoader）

- C/C++实现，嵌套在JVM内部
- 用于加载Java核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
- 不继承`java.lang.ClassLoader`，无父加载器
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

#### 扩展类加载器（Extension ClassLoader）

- Java 编写，派生于ClassLoader，由sun.misc.Lancher$ExtClassLoader实现
- 父加载器为启动类加载器
- 从 java.ext.dirs系统属性所指定的目录下加载类库，或JAVA_HOME/jre/lib/ext下加载。用户创建的jar放在此目录下也会被加载

#### 应用程序类加载器（系统类加载器，AppClassLoader）

- Java编写，派生于ClassLoader，sun.misc.Lancher$AppClassLoader实现
- 父加载器为扩展类加载器
- 用于加载环境变量classpath或系统属性java.class.path指定路径下的类库
- 该加载类是程序中默认的类加载器，一般来说Java应用都是由他加载
- 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

#### 用户自定义加载类

（与上面的自定义类加载器区分，这个需要用户自己编写）

为什么要自定义？

- 隔离加载类
- 修改类的加载方式
- 扩展加载源
- 方式源码泄露

实现步骤

1. 继承抽象类java.lang.ClassLoader，重写loadClass()方法
2. JDK1.2以后不建议用户重写loadClass()，而是建议把自定义类的加载逻辑写在findClass()方法中
3. 编写时，若无复杂需求，可以继承URLClassLoader类可以避免编写findClass()及获取字节码流的方式

### 双亲委派机制

Java虚拟机对class文件采取按需加载的方式，当需要使用时才会将他的class文件加载到内存，而加载某个类的class文件时采取的就是双亲委派模式

![image-20210616194000343](https://gitee.com/vergeee/static-repo/raw/master//img/20210616194007.png)

1. 当一个类加载器收到类加载请求，他并不会自己去加载，而是委托给自己的父类
2. 若父类还存在父类，那就继续委托，直到到达顶层的引导类加载器
3. 如果引导类加载器可以完成加载就成功返回，否则子加载器才会自己尝试加载

作用：

1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意更改

## 运行时数据区

![第02章_JVM架构-英](https://gitee.com/vergeee/static-repo/raw/master//img/20210615131534.jpg)

![image-20210706195149000](https://gitee.com/vergeee/static-repo/raw/master//img/20210706195149.png)

### 程序计数器（PC Register）

- 很小的一块空间，几乎可以忽略不记，运行速度最快的存储区域
- 每个线程一份，是线程私有的，生命周期与线程的生命周期保持一致
- 一个线程任何时间都有一个方法在执行，也就是**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或在执行native方法（什么是native方法 https://www.jianshu.com/p/22517a150fe5，简单地讲，一个Native Method就是一个java调用非java代码的接口）时则是未指定值（undefined）

两个问题

1. 使用PC寄存器存储字节码指令的地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？

因为CPU需要不停的切换各个线程，切回来之后需要知道从哪继续执行

2. PC寄存器为什么会被设定为线程私有

我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢?为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程，都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢?每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

### 虚拟机栈

栈解决程序**运行问题**，即程序**如何执行**、或如何处理数据。**堆**解决的是**数据存储**的问题，解决**存在那和怎么放**的问题

- 每个线程都会创建一个虚拟机栈，其内部保存一个个栈帧（Stack Frame），对应一次次方法调用
- 与线程的生命周期一致
- 主管Java程序的运行，保存方法的局部变量、部分结果，参与方法的调用与返回

#### 栈的特点

- 栈是一种快速有效的分配存储的方式，访问速度仅次于程序计数器
- JVM对Java栈的操作只有两个
  - 方法执行伴随进栈
  - 执行结束后出栈
- 栈没有垃圾回收问题

#### 栈可能出现的异常

- StackOverflowError

如果采用固定大小的Java虚拟机栈，每个虚拟机栈容量可以在线程创建的时候选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，虚拟机将会抛出StackOverflowError

- OutOfMemoryError

Java虚拟机栈可以动态扩展，在尝试扩展的适合无法申请到足够的内存或在创建时没有足够内存去创建对应的虚拟机栈，那Java虚拟机会抛出OutOfMemoryError

#### 栈帧

- 栈中的数据以栈帧的格式存在
- 此线程上正在执行的每个方法都对应自己的一个栈帧
- 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息



- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧**（Current Frame），与当前栈帧对应的方法就是**当前方法**（Current Method），定义这个方法的类就是**当前类**（Current Class）
- 执行引擎运行的所有字节码指令只会对当前栈帧进行操作
- 如果在该方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的顶端，成为新的当前帧



- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

     

     

     ##### 栈帧的内部结构

- 局部变量表(Local variables)

- 操作数栈(Operand Stack) (或表达式栈)

- 动态链接(Dynamic Linking) (或指向运行时常量池的方法引用)

- 方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)

- --些附加信息

![img](https://gitee.com/vergeee/static-repo/raw/master//img/20210712123233.png)

##### 局部变量表

又称局部变量数组或本地变量表



定义为一个**数字数组**，主要用于存储方法参数和定义在方法体内部的**局部变量**，这些数据类型这些数据类型包括各类基本数据类型、对象引用(reference)，以及
returnAddress类型。

由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题

局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改
变局部变量表的大小的。



```java
public class AESTest {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = 3;
    }
}
```



![img](https://gitee.com/vergeee/static-repo/raw/master//img/20210712142509.png)

局部变量表的单位是Slot

在局部变量表里32位以内的类型只占用一个slot,64位的占用两个slot



在局部变量表里，32位以内的类型只占用一个slot (包括returnAddress类型)，64位的类型(long和double)占用两个slot。

- byte 、short、char在存储前被转换为int， boolean 也被转换为int，0表示false，非0表示true。
- long和double则占据两个Slot。



```java
public class AESTest {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = 3;
        double d = 4.0;
        long e = 1000000000;
        Double f = 1.1;
    }
}
```

![img](https://gitee.com/vergeee/static-repo/raw/master//img/20210712143405.png)

JVM会为局部变量表中的每一个Slot都分配一一个访问索引，通过这个素引即可成功访问到局部变量表中指定的局部变量值

当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上

如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可（例如double d 访问4就行）
如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

我们知道类变量表有 两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中
定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。



##### 操作数栈（表达式栈）

用于**保存计算过程的中间结果**，同时作为计算过程中变量临时的存储空间



操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧将会被创建，这个方法的操作数栈是空的



每一个操作数栈都有一个明确的栈深度用于存储数值，所需最大深度在编译期就定义好了，保存在Code属性中

![img](https://gitee.com/vergeee/static-repo/raw/master//img/20210712165722.png)

- 栈中的任何一个元素都可以是任意的Java数据类型。
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。



如果被调用的方法有返回值的话，其返回值就会被压入**当前栈帧**的操作数栈中



PC寄存器，局部变量表，操作数栈具体怎么执行字节码，执行过程看（https://www.bilibili.com/video/BV1PJ411n7xZ?p=53）

具体字节码操作含义看（https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-6.html）



##### 动态链接

每个栈帧内部都包含一个指向**运行时常量池**中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码实现**动态链接**(Dynamic Linking)

在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference) 保存在class文件的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**



##### 方法调用

当子类和父类（接口和实现类）存在同一个方法时，子类重写父类（接口）方法时，程序在运行时调用的方法时，是调用父类（接口）的方法呢？还是调用子类的方法呢？我们将确定这种调用何种方法的操作称之为绑定。绑定又分为静态绑定和动态绑定。

静态绑定

静态绑定是在程序执行前就已经被绑定了(也就是在程序编译过程中就已经知道这个方法是哪个类中的方法)

注：Java中只有private、static和final修饰的方法以及构造方法是静态绑定。

a、private方法的特点是不能被继承，也就是不存在调用其子类的对象，只能调用对象自身，因此private方法和定义该方法的类绑定在一起

b、static方法又称类方法，类方法属于类文件。它不依赖对象而存在，在调用的时候就已经知道是哪个类的，所以是类方法是属于静态绑定。

c、final方法：final方法可以被继承，但是不能被重写，所以也就是说final方法是属于静态绑定的，因为调用的方法是一样的。

 总结：如果一个方法不可被继承或者继承后不可被覆盖，那么这个方法就采用的静态绑定。

动态绑定

没看明白。。。先不写了

##### 返回地址

