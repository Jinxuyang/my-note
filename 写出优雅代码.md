[TOC]

# 关于面向对象编程

## 什么是面向对象编程

一种编程范式或编程风格。以类或对象作为组织代码的基本单元，将封装、继承、多态、抽象作为代码设计和实现的基石。

## 什么是面向对象编程语言

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继 

承、多态）的编程语言。 

## 面向对象编程和面向对象语言之间的关系

不使用面向对象编程语言也可以进行面向对象编程，使用面向对象编程语言也可以进行面向过程编程

## 什么是面向对象分析和面向对象设计

简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程 

序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互等等。 

## 四个特性

### 封装

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数 

据。它需要编程语言提供权限访问控制语法来支持，例如Java中的private、protected、public关键字。封装特性存在的意义， 

一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

### 抽象

封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不 

需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的 

意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂 

系统的有效手段，能有效地过滤掉不必要关注的信息。 

### 继承

继承是用来表示类之间的is-a关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个 

子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的 

问题。

#### Java 不支持多重继承的原因 

多重继承有副作用：钻石问题(菱形继承)。 

假设类 B 和类 C 继承自类 A，且都重写了类 A中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 

的方法，那对于 B、C 重写的 A中的方法，类 D 会继承哪一个呢？这里就会产生歧义。 

考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的，就算一个类实现了多个接口，且这些接口中存在某个同名方法，但 是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。

从jdk1.8开始，接口可以有默认方法(方法要用default标识)，必须要有方法体，这样在接口多继承上不也会有决议问题吗？java发现这种情况，会通过让你强制在子接口中重写这个默认方法，这样就不会有决议问题了

python支持多继承因为它通过MRO解决的

### 多态

多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法 

机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧 

的代码实现基础。

## 贫血模型

又称为失血模型，是指domain object仅有属性的getter/setter方法的纯数据类，将所有类的行为放到service 层。

## 接口和抽象类

### 接口

Java接口中可以定义静态方法、default方法，枚举类型，接口中还可以定义接口（嵌套）。类实现接口的时候，必须实现接口中声明的所有方法。 

```java
public interface ILog { 
    enum Type { 
        LOW, 
        MEDIUM, 
        HIGH 
    }
    interface InILog { 
        void initInLog();
    }
    default void init() { 
        Type t = Type.LOW; 
        System.out.println(t.ordinal()); 
    }
    static void OS() { 
        System.out.println(System.getProperty("os.name", "linux")); 
    }
    void log(OutputStream out); 
}

class ConsoleLog implements ILog { 
    @Override 
    public void log(OutputStream out) { 
        System.out.println("ConsoleLog..."); 
    }
}
```



### 抽象类

抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代 

码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。

### 存在意义

抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种has-a关 

系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

### 应用场景区别

如果要表示一种is-a的关系，并且是为了解决代码复 

用问题，我们就用抽象类；如果要表示一种has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。

## 基于接口而非实现编程

### 如何

1. 函数的命名不能暴露任何实现细节。比如，uploadToAliyun()就不符合要求，应该改为去掉aliyun这样的字眼， 改为更加抽象的命名方式，比如：upload()。 

2. 封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程 进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用。 

3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。

### 需要为所有类定义接口吗

如果某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们 就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

当实现不稳定时要封装不稳定的类，提供稳定的接口。

除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之 

后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。

# SOLID原则

## 单一职责原则（Single Responsibility Principle，SRP）

A class or module should have a single responsibility

这个原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代 码块，模块中包含多个类，多个类组成一个模块。

### 如何判断类的职责是否单一

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 

- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 

- 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性；

- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰； 

- 类中大量的方法都是集中操作类中的某几个属性，比如，在UserInfo例子中，如果一半的方法都是在操作address信息，那 就可以考虑将这几个属性和对应的方法拆分出来。 



在不同的场景下、不同阶段下对于同一个类的职责是否单一的判定都是不一样的

**可以先写一个粗粒度的类，满足业务需求。随着业务的发展，粗粒度的类越来越大，可以将这个类拆分成几个细粒度的类**。

### 类的职责是否越单一越好

不是

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

实际上，不管是应用设计原则还是设计模式，最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准



### 内聚和耦合

内聚和耦合其实是对一个意思（即合在一块）从相反方向的两种阐述。 

1. 内聚是从功能相关来谈，主张高内聚。把功能高度相关的内容不必要地分离开，就降低了内聚性，成了低内聚。 

2. 耦合是从功能无关来谈，主张低耦合。把功能明显无关的内容随意地结合起来，就增加了耦合性，成了高耦合。 

## 开闭原则（Open Closed Principle, OCP）

软件实体（模块、类、方法等） 应该“对扩展开放、对修改关闭”

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。

- 开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
- 同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。 

### 如何做到

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。 

## 里氏替换（Liskov Substitution Principle，LSP）

子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

看起来多态和里氏替换很相似

多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

### 里氏替换的反例

1. 子类违背父类声明要实现的功能
2. 子类违背父类对输入、输出、异常的约定
3. 子类违背父类 中所罗列的任何特殊说明

## 接口隔离原则（ Interface Segregation Principle，ISP）

如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。 

如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个 函数，让调用者只依赖它需要的那个细粒度函数。 

如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的 实现类和调用者，依赖不需要的接口函数。

### 接口隔离原则和单一职责原则的区别

单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。 如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。 

## 依赖反转原则（Dependency Inversion Principle，DIP）

1. 控制反转

   实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控 

   制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之 

   后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。 

2. 依赖注入

   依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的 

   类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。 

3. 依赖注入框架

   我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对 

   象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。 

4. 依赖反转原则

   依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模 

   块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

# KISS,YAGNI原则

KISS: Keep It Simple and Stupid.

意思就是尽量保持简单

不是代码行数越少就越简单，代码逻辑复杂也不一定违背KISS

## 如何写出满足KISS的代码

- 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。 

- 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出bug的概率会更高，维护的成本也比较高。 

- 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。 





YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。

比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前， 我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。

YAGNI原则跟KISS原则并非一回事儿。KISS原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI原则说的是“要不要做”的问题（当前不需要的就不要做）。 

# DRY

Don’t Repeat Yourself。

中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。

并不是说某个方法代码相同就违背了DRY，比如两个代码实现逻辑上是相同的，但是语义上不重复（从功能上来看，这两个函数干的是完全不重复的两件事情），这就不违反DRY；又比如两个方法的实现逻辑各不相同，但都实现了一个目标，这就违反了DRY；还有一类违反DRY的是代码执行重复，比如在某个流程中，需要校验邮箱是否合法，而在这个流程中的两个环节都进行了校验这就违反了DRY

## 如何提高代码复用性

- 减少代码耦合 

- 满足单一职责原则 

- 模块化 

- 业务与非业务逻辑分离通用代码下沉 

- 继承、多态、抽象、封装 

- 应用模板等设计模式

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

# 迪米特法则（Lawof  Demeter，LOD）

最小知识原则

Each unit should have only limited knowledge about other units: onlyunits “closely” related to the current unit.Or: Each unit should only talk to its friends;Don’t talk to strangers. 

每个模块（unit）只应该了解那些与它关系密切的模块（units: onlyunits “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口



