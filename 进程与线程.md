## 中断、异常、系统调用

 ### 为什么需要

计算机运行中内核是被信任的第三方、只有内核可以执行特权指令，但是内核还需要提供给其他应用程序使用的接口

### 中断和异常希望解决的问题

当I/O设备，例如键盘输入时为了快速响应键盘的输入

应用程序运行过程中，总有意外情况在事先写程序时是无法预料的，因此提供异常交给操作

### 系统调用希望解决的问题

用户的应用程序如何得到系统服务



- 系统调用
  - 应用程序主动向操作系统发出的服务请求
- 异常
  - 非法指令或娶她原因导致当前指令执行失败后的处理请求
- 中断
  - 来自硬件设备的处理请求



### 区别

应用程序和内核打交道的就是中断、异常、系统调用这三个接口

- 来源

​		中断：外设

​		异常： 应用程序出乎意料的行为

​		系统调用：应用程序请求操作提供的服务

- 响应方式

  中断：异步

  异常：同步

  系统调用：异步或同步

- 处理机制

  中断：持续，对用户应用程序是透明的

  异常：杀死或重新执行意想不到的应用程序指令

  系统调用：等待和持续

  

### 如何处理处理这三种“请求”

硬件

- 在CPU初始化时设置中断使能标志
  - 依据内部或外部事件设置中断标志
  - 依据中断向量调用响应中断服务例程

软件

- 现场保护
- 中断服务处理
- 清除中断标记
- 现场恢复

### 中断嵌套 

硬件中断服务例程可被打断

- 不同硬件中断源可能在硬件中断处理时出现
- 硬件中断服务例程中休要临时禁制中断请求
- 中断请求会保持到CPU做出响应

异常服务例程可被打断

- 异常服务例程执行时可能出现硬件中断

异常服务例程可嵌套

- 异常服务例程可能出现缺页

  





## 进程

### 定义

进程时指一个具有独立功能的程序在一个**数据集合**上的一次**动态执行**过程

进程包含可正在运行的一个程序的所有状态信息

代码、数据、状态寄存器、通用寄存器、进程占用的系统资源...这些东西构成了**进程控制块**

### 进程的特征

- 动态性
  - 进程可以动态的创建和销毁
- 并发性
  - 进程可以被独立调度并占用处理器运行
  - 可以交替执行多个程序，在宏观上体现出线程的并发性
- 独立性
  - 不同进程之间不受影响
- 制约性
  - 因访问共享数据/资源或进程间同步产生制约

如何权衡独立性与制约性是一个问题

### 进程与程序

#### 联系

进程是操作系统处于执行状态程序的抽象

- 程序是一个文件（静态可执行文件）
- 进程是执行中的程序是程序加上执行状态

同一个程序的多次执行过程对应不同的进程

进程的执行需要资源

#### 区别

进程是动态的、程序是静态的

进程是暂时的，程序是永久的

进程与程序的组成不同

### 进程控制块（PCB）

管理控制进程运行所用的信息集合

- 操作系统用PCB来描述进程的基本情况以及运行变化的过程
- PCB是进程存在的唯一标志，每个进程都对应一个PCB

#### 使用

进程创建时生成PCB，结束时回收PCB，进程的控制通过PCB

#### 内容

调度和状态信息

进程间通信信息

存储管理信息

进程所用资源

有关数据结构连接信息

### 进程的状态



<hr>

在任何多道程序设计系统中，CPU由一个进程快速切换到另一个进程，使每个进程各运行几十或几百毫秒。严格来说，在某个瞬间，CPU只能运行一个进程，但在一秒中它可以运行多个进程，这就是有时人们说的**伪并行**

### 进程模型

跟踪CPU在任如何在程序间来回切换是很困难的，因此操作系统的开发者设计开发了用于描述并行的一种概念模型。

进程模型中，计算机上所有可运行的软件，也包括操作系统，被组织成若干顺序进程，简称**进程**。

概念上说每个进程拥有自己的虚拟CPU，实际上是CPU在各个程序间来回切换，这种快速切换称作**多道程序设计**

一个进程是某种类型的一个活动，他有程序、输入、输出、状态。单个处理器可以被若干进程共享，它使用某种调度算法决定如何停止一个进程的工作为另一个进程提供服务

###  进程的创建

四种时间会导致进程的创建

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新的线程
- 一个批处理作业（**批次处理任务**，是指在计算机上无须人工干预而执行系列程序的作业）的初始化

这些创建方式都是由一个已经存在的进程执行了一个用于创建进程的系统调用创建的（**有待补充**）

UNIX创建新进程只有一个系统调用**fork**，fork会创建一个与调用进程相同的副本，调用了fork后两个进程需要用于相同的内存映像，接着子进程执行**execve**或类似的系统调用，用这个修改内存映像并运行一个新的程序。

Windows中，Win32函数调用CreateProcess处理进程的创建，也负责把正确的程序装入新的进程



进程创建后，父进程和子进程有不同的地址空间。狗哥进程在其地址空间中修改了一个字，这个修改对其他进程是不可见的。



### 进程的终止

- 正常退出（自愿）
- 出错退出（自愿）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）

多数进程是由于完成了它们的工作。当编译器完成了给定的编译之后编译器执行一个系统调用通知操作系统工作已完成。UNIX中是exit，Windows中是ExitProcess。

### 进程的层次结构

当进程创建了另一个进程之后，父进程和子进程以某种形式继续保持关联，子进程可以创建更多的进程，形成一种树状结构。UNIX的整个系统所有进程都属于以init为根的一棵树。

Windwos中没有进程层次的概念，创建进程时父进程可以得到一个特别的令牌称为句柄，可以用来控制子进程，但父进程有权把这个令牌传给其他进程。

### 进程的状态

![image-20211130214132034](https://raw.githubusercontent.com/Jinxuyang/my-note/master/assets/image-20211130214132034.png)

1. 运行态（该时刻进程实际占用CPU）
2. 就绪态（可运行，但其他进程正在占用CPU）
3. 阻塞态（进程正在等待某种外部事件的发生，在发生前进程不能运行）

### 进程的实现

为了实现进程模型，操作系统维护着一张表格，**进程表**。

每个进程占用一个进程表项，该表包含了进程状态的重要信息，保证该进程随后能再次启动。

![image-20211130214648621](https://raw.githubusercontent.com/Jinxuyang/my-note/master/assets/image-20211130214648621.png)

## 线程

为了在进程内部进一步提高并发性

进程存在的问题：

1. 进程之间如何通信，共享数据
2. 创建、结束、切换进程的开销较大

因此在进程内添加一类实体，满足

1. 实体之间并发执行
2. 实体之间共享相同的地址空间

这个实体就是线程

线程是进程的一部分，描述指令流执行状态。他是进程中的指令流执行的最小单端，是CPU调度的基本单位。

### 进程控制块的变化

![img](https://raw.githubusercontent.com/Jinxuyang/my-note/master/assets/VV26867(Y%7E%25P)Z07PWXR4PJ.png)

![img](https://raw.githubusercontent.com/Jinxuyang/my-note/master/assets/%40SQG7NVB4%25L%40GPMLJGK%250UN.png)

### 比较

- 进程是资源分配的单位，线程是CPU调度单位
- 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
- 线程具有就绪、等待和运行三种基本状态和状态间的转换关系
- 线程的创建终止切换开销都比进程小
- 线程之间资源共享

## 进程切换(上下文切换)

暂停当前运行的进程，从运行状态变为其他状态

调度另一个进程从就绪状态变为运行状态

切换前保存进程上下文，切换后恢复进程上下文

进程生命周期信息包含寄存器、CPU状态、内存地址空间



内核为每个进程维护了对应的进程控制块

内核将相同状态的进程的PCB防止在同一队列

- 就绪队列

- I/O等待队列

- 僵尸队列

  

## 处理机调度

从就绪队列中挑选下一个占用CPU运行的进程，从多个可用CPU中挑选就绪进程可使用的CPU

调度程序就是一个挑选就绪进程的内核函数

调度策略：依据什么原则挑选进程/线程

调度时机：什么时候进行调度

### 调度时机

进程从运行状态切换到等待状态

进程被终结

- 非抢占式系统

  当前进程主动放弃CPU

- 可抢占式系统

  - 中断进程被服务例程响应完成时
  - 当前进程被抢占
    - 进程的时间片用完
    - 进程从等待切换到就绪
    - 

### 调度算法

  #### 先来先服务（FCFS）

依据进程进入就绪状态的先后顺序排列

优点简单，但是平均等待时间波动大，I/O资源和CPU资源利用效率低 ，CPU密集型进程会导致I/O设备闲置时间边长

#### 短进程优先算法（SPN）

选择就绪队列中执行时间最短的进程占用CPU

就绪队列按照预期执行时间进行排序

##### 短剩余时间优先（SRT）

SPN算法的可抢占改进

SRT具有最优的平均周转实现（进程的等待时间）

但是可能导致饥饿：连续的短进程会导致长进程无法获得CPU资源

还需要**预知执行时间**

两种估计时间

- 询问用户
  - 用户欺骗就杀死进程
  - 存在问题，用户也不知道执行时间
- 用历史信息预估未来
  - 最近一次执行时间对于预估时间的影响最大，后续影响依次递减

#### 最高响应比优先

选择就绪队列中响应比R值最高的进程

R=(w+s)/s

w: 等待时间，s: 预估执行时间

等待时间会随着时间流逝越来越大，R值也就越来越大，防止进程等待时间过长



不可抢占

关注进程的等待时间

避免无限期等待

#### 时间片轮转算法（RR）

  时间片：分配处理机资源的基本时间单位

时间片结束时，按FCFS算法切换到下一个就绪进程



RR算法有额外的上下文切换开销

时间片设置过大，大到足以让每个进程都执行完成，会导致算法退化成FCFS

时间片设置过小，反应迅速，但会导致上下文切换的开销过大

时间片长度的选择只有一些经验值：维持上下文切换的开销处于1%，10ms

 #### 多级队列调度算法（MQ）

- 就绪队列被划分为多个独立的子队列

- 每个队列拥有自己的调度策略

- 队列间的调度

