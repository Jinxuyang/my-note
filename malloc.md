---
title: malloc()函数的用法/动态内存分配
date: 2020-03-03 15:11:37
tags:
---

### 计算机内存

计算机的内存从高位到低位分别是**系统内核-栈-可自由分配的空间-堆-数据段-代码段**

源代码编译后的二进制文件会加载到内存中的**代码段**

数据段包含了在程序中明确被**初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）**。

<!--more-->

> - 栈存储区：
>
> **通常存放程序临时创建的局部变量（但不包括static声明的变量，static意味着在数据段中存放变量）**，即函数括大括号 “{ }” 中定义的变量，其中还包括函数调用时其形参，调用后的返回值等。
>
> 最后栈还具有“小内存、自动化、可能会溢出”的特点。栈顶的地址和栈的最大容量一般是系统预先规定好的，通常不会太大。由于栈中主要存放的是局部变量，而局部变量的占用的内存空间是其所在的代码段或函数段结束时由系统回收重新利用，所以栈的空间是循环利用自动管理的，一般不需要人为操作。如果某次局部变量申请的空间超过栈的剩余空间时就有可能出现 “栈的溢出”，进而导致意想不到的后果。**所以一般不宜在栈中申请过大的空间，比如长度很大的数组、递归调用重复次数很多的函数等等**。
>
> - 堆存储区：
>
> **通常存放程序运行中动态分配的存储空间。**它的大小，并不固定，可动态扩张或缩放。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被提出（堆被缩减）。
>
> (堆是低地址向高地址扩展的数据结构，是一块不连续的内存区域。**在标准C语言上，使用malloc等内存分配函数是从堆中分配内存的**
>
> 堆具有“大内存、手工分配管理、申请大小随意、可能会泄露”的特点，堆内存是操作系统划分给堆管理器来管理的，管理器向使用者（用户进程）提供API（malloc和free等）来使用堆内存。需要程序员手动分配释放，如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了（进程自身认为该内存没被使用，但是在堆内存记录中该内存仍然属于这个进程，所以当需要分配空间时又会重新去申请新的内存而不是重复利用这块内存），就是我们常说的内存泄漏，所以内存泄漏指的是堆内存被泄露了。

<br>

### malloc()用法

#### malloc()函数的原型

```c
#include<stdlib.h>
void *malloc(unsigned long size);
```

#### 功能

size应该为整型

分配一个size这么大的内存，返回一个指向这片内存空间的起始位置的一个指针，类型为void*、

若空间不足则或者其他原因没有成功申请到内存则返回NULL

#### 如何使用

```c
int *p = (int *)malloc(4);
```

它的意思是：请求系统分配 **4 字节**的内存空间，并**返回第一字节的地址**，然后赋给指针变量 p。

> 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。
> 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）

C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）。或者自己进行强制类型转换也可以

void\*与void不同，void\* 是定义一个无类型的指针变量，它可以指向任何类型的数据。任何类型的指针变量都可以直接赋给 void* 型的指针变量，无需进行强制类型转换。

**注意，不能对 void* 型的指针变量进行运算操作，如指针的运算、指针的移动等。原因很简单，前面讲int*型的指针变量加 1 就是移动 4 个单元，因为 int\* 型的指针变量指向的是 int 型数据；但是 void\* 型可以指向任何类型的数据，所以无法知道“1”所表示的是几个内存单元。**

### free()

用于释放使用malloc动态分配的内存

#### 原型

```c
void free(void *ptr);
```





**参考**：http://c.biancheng.net/view/223.html

​		    https://blog.csdn.net/weixin_39371711/article/details/81783780